<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        pre {
            background-color: rgb(211, 211, 211);
            padding: 2px;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <h1>JAVASCRIPT - notatki</h1>
    <p>Przydatne linki
        <ul>
            <li><a href="https://developer.mozilla.org/pl/docs/Learn/JavaScript/Pierwsze_kroki/What_is_JavaScript"
                    target="_blank">KURS JS na MDN</a></li>
            <li><a href="http://kursjs.pl/index.php">KURS JS dla superbohaterów - SUPER STRONA</a></li>
            <li><a
                    href="https://technikinformatyk.pl/kursy/kurs/javascript/lekcja/javascript-petle-cwiczenia-interaktywne/">cwiczenia</a>
            </li>
        </ul>
    </p>


    <h2>TWORZENIE ZMIENNEJ</h2>
    <ol>
        <li>zmienne tworzymy zawsze po angielsku</li>
        <li>wielkość liter ma znaczenie - javascript jest jezykiem case sensitive</li>
        <li>najlepiej uzywac notacji wielbłądziej camelCase</li>
        <li>w zmiennej nie możemy używać myślników(minus), kropek, spacji (jedynie _)</li>
        <li>nie możemy ustwaiać cyfr jako pierwszego znaku w nazwie zmiennej</li>
        <li>nie rozpoczynamy nazwy zmiennej od dużej litery</li>
        <li>nie mozemy uzyć zarezerwowanego słowa <a
                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar">lista na
                mdn</a>

        </li>
        <li>zakres lokalny i globalny - jezeli zmienna jest zadeklaroawna w zakresie globalnym mamy do niej dostep w
            każdym miejscu kodu, jesli jest zadeklarowana w zaresie lokalnym (wewn jakiejs funkcji) to mamy do niej
            dostep w obrebie tej funcji</li>
        <li>do zmiennej globnalnej przed nazwa funcji dodajemy znak dolara (dobra praktyka a nie obowiazek), zeby bylo
            wiadomo ze jest to zmienna globalna</li>
        <li>w zmiennej lokalnej mozemy zadeklaroawc jeszecze raz taka sama zmienna i nie wplynie ona na globalna</li>
    </ol>
    <h2>TYPY DANYCH</h2>
    <h3>TYPY PROSTE</h3>
    <p>SUPER STRING / TEMPLATE STRING - stringa zaisujemy w grawisach a nie w cudzyslowiach </p>
    <ul>
        <li>console.log(`Cześć, jestem ${name} i mam ${age} lat`);</li>
        <li>starym sposobem zapisalibysmy to tak
            <pre>console.log('Cześć, jestem ' + name + ' i mam ' + age + ' lat');</pre>
        </li>
        <li>w super string zeby tekst przeszedł do nowej linii wystarczy kliknać (enter) <br>
            starym sposobem w stringu musielibysmy wpisac "\n" (takie br)

        </li>
    </ul>
    <p>STRING METODY - ważne</p>
    <ul>
        <li>.includes() - sprawdza czy jakis string jest zawarty w innym stringu</li>
        <li>.indexOf() - podaje liczbe jaka jest ilosc znakow do pierwszego wyszukiwanego slowa (mozna wpisac wartosc
            poczatkowa</li>
        <li>.lastIndexOf() - podaje liczbe jaka jest ilosc znakow do ostatniego wyszukiwanego slowa (mozna wpisac
            wartosc poczatkowa</li>
        <li>.match() - sprawdza czy wyrażenie pasuje do złożonego wzorca</li>
        <li>.padStart() i .padEnd() - służą do „automatycznego” rozszerzania ciągu znaków. przyjmują dwa argumenty
            (dlugosc o ile ma byc ciag rozszerzony a drugi znak/i o jakie ma byuc roszerzony</li>
        <li>.repeat - słzy do powtarzania stringa odpowiednia ilosc razy zadeklarowana w funkcji</li>
        <li>.repalce - zamienia stringi zadeklaroawne </li>
        <li>.slice - Wydobywa część łańcucha znaków i zwraca go jako nowy łańcuch znaków.</li>
        <li>.split - Rozbija podany tekst na tablicę mniejszych kawałków, z których każdy w oryginalnym tekście był
            rozdzielony od pozostałych określonym separatorem. Sam separator nie jest dołączany do wynikowej tablicy.
        </li>
        <li>startsWith() - sprawdza czy string zaczyna sie od zdeklarowanego innego stringa (mozna podac od ktorego
            znaku ma sprawdzac</li>
        <li>.substring - Metoda ta wycina z danego tekstu łańcuch (zwraca podciąg) począwszy od wskazanej pozycji
            (licząc od zera) do pozycji końcowej podciągu.</li>
        <li>.trim - usuwa białę znaki przed i po ciagu znaków (sa rowniez triomEnd i .trimStart</li>
    </ul>
    <p>NUMBER METODY</p>
    <ul>
        <li>.isInteger() - Sprawdza czy liczba jest całkowita.</li>
        <li>.toFixed() - można ustalć miejsca po przecinku</li>
        <li>.toPrecision - uśrednia do zadeklarowanej ilosci miejsc po przecinku</li>
    </ul>
    <p>BOOLEAN</p>
    <ul>
        <li>boolaan zwraca true jesli jest podana wartosc lub wpiszemy true lub w stringu sa znaki </li>
        <li>bolean zwraca false jesli ustawimy false, undefined, null, 0, NaN lub pusty string</li>
    </ul>
    <p>UNDEFINED - jesli nie przypiszemyu wartosci to js ustali wartosc na undefined </p>
    <p>NULL - podobny do undefined ale to umieszczamy w kodzie kiedy tego chcemy</p>
    <p>SYMBOL - przydaje sie przy obiektach
    </p>

    <h3>TYPY ZŁOŻONE (OBIEKTY)</h3>
    <ul>
        <li>obiekty - wpisujemy w nawiasach klamrowych</li>
        <li>funkcje</li>
        <li>tablice - do tablicy mozemy wpisac kazdy rodzaj danych</li>
    </ul>


    <h2>PĘTLE</h2>
    <p>Pętle tworzymy tak jak instrukcje np for(){}</p>
    <h3>Pętla FOR</h3>
    <p>tworzenie pętli for
        <pre>for (zainicjowanie_zmiennych; warunek_kończący_wykonywa
        nie_pętli; zmiana_zmiennych) { <br> kod który zostaniewykonany pewną ilość razy }</pre>

        <pre>example:for (let i = 0; i"znak_mniejszości"5; i++){}</pre>
    </p>
    <h3>Pętla WHILE</h3>
    <p>pętla while wykonuje się tak długo dopóki jakiś warunek nie zostanie spełniony</p>
    <p>tworzenie pętli while
        <pre> while (warunek_kończący_wykonywanie_pętli) { instrykcje }</pre>
        example:
        <pre>let i = 0;
while (i"znak_mniejszości"5{
    consol.log(i)
    i++
}</pre>
    </p>
    <h3>Pętla DO...WHILE</h3>
    <p>pętla while wykonuje się tak długo dopóki jakiś warunek nie zostanie spełniony. Wykonuje są przynajmniej raz.
        (jest taka jakby while od konca</p>
    <p>tworzenie pętli do..while

        <pre>do
    {polecenia}
while (warunek_kończący_wykonywanie_pętli)</pre>
        example:
        <pre>do{
    i++;
    console.log(`I po iteracji ${i}`);
}
while (i"znak_mniejszości"5{
}</pre>

    </p>
    <h3>Pętla FOR OF</h3>
    <p>do pracy na tablicach</p>
    <p>dobrze zeby nazwa zmiennej odnosiła się do nazwy tablicy (np .numbers->number lub fruits->fruit)</p>
    <p>trzeba uważać!!! bardzo ważne żeby używać słowa kluczowego (let/const) przy deklarowaniu zmiennej w petli for of
        aby nie wpakować zmiennej jako globalnej</p>
    <p>tworzenie pętli for of

        <pre>
let/const nazwa tablicy = []
for (let/const nazwa_zmiennej of nazwa tablicy){
    polecenia
}
</pre>
        example:
        <pre>
let numbers = [1,2,3,4,5]
for (const number of numbers){
    console.log(number *2)
}</pre>

    </p>
    <h3>Pętla FOR IN</h3>
    <p>do pracy na obiektach</p>

    <p>tworzenie pętli for in

        <pre></pre>
        example:
        <pre></pre>

    </p>
    <h3>Pętla FOREACH</h3>
    <p>Wykonuje dostarczoną funkcję jeden raz na każdy element tablicy. Oczywiście możesz to samo zrobić za pomocą for,
        ale forEach wygląda bardziej intuicyjnie.</p>
    <p>do petli foreach musimy dostać się za pomocą funkcji</p>
    <p>tworzenie pętli foreach

        <pre>
nazwa_tablicy.forEach(funkcja_callback[, thisArg])
</pre>
        example:
        <pre>
const numbers = [1, 2, 3, 4, 5];
const newNumbers = numbers.forEach(el => console.log(el*2));</pre>
        instrukcja do przykłądu dla każdego elementu tablicy numbers (el) ma wykonać się jakaś funkcja
        (clg(el*2)) czyli kazdy elelemnt zostanie pomnozopny razy 2 i wylogowany w konsoli (element pod element el
        podklada sie element z tablicy numbers, wykonuje się funcja i tak dla kazdego elememntu tablicy)
    </p>

    <h2>TABLICE</h2>
    <p>METODY NA TABLICACH <a
            href="https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Obiekty/Array">MDN</a></p>
    <p>w tablicy możemy przechowywać wszystkie typy zmiennych</p>
    <p>mamy metody destrukcyjne i niedestrukcyjne. destrukcyjne zmieniaja zawartosc tablicy (np shift, unshift, pop,
        push), a niedestukcyjne nie zmieniaja zawartosci tablicy tylko wykorzystuja ja i tworza nowa zmienna (np map)
    </p>
    <p>tablicę tworzymy poprzez let/const np:
        <pre>let arr = []</pre>lub poprzez konstruktor new i słowo kluczowe array
        <pre>const arr = new Array(5)</pre> stworzyliśmy w ten sposób pustą pięcioelementową tablicę</p>
    <ol>
        <li>UNSHIFT</li>
        <p>Dodaje jeden lub więcej elementów na początek tablicy i zwraca jej nową długość.</p>
        <li>SHIFT</li>
        <p>Usuwa pierwszy element z tablicy i zwraca go. Metoda ta zmienia długość tablicy.</p>
        <li>PUSH</li>
        <p>Dodaje jeden lub więcej elementów na koniec tablicy i zwraca jej nową długość. Metoda ta zmienia długość
            tablicy.</p>
        <li>POP</li>
        <p>Usuwa ostatni element z tablicy zwracając go. Metoda ta zmienia długość tablicy.</p>
        <li>MAP</li>
        <p>tworzy nową tablicę zawierającą wyniki wywoływania podanej funkcji dla każdego elementu wywołującej tablicy.
            <pre>let strings = ["hello", "Array", "WORLD"];

function makeUpperCase(v)
{
    return v.toUpperCase();
}

let uppers = strings.map(makeUpperCase);

// uppers są teraz pisane wielkimi literami ["HELLO", "ARRAY", "WORLD"]
// strings są niezmienione</pre>
        </p>
        <li>CONCAT</li>
        <p>Zwraca nową tablicę złożoną z tablicy, na której wywołano tę metodę, połączonej z innymi podanymi tablicami
            lub wartościami.</p>
        <pre><b>Przykład: Połączenie dwóch tablic</b> 

alpha = new Array("a", "b", "c");
numeric = new Array(1, 2, 3);
alphaNumeric = alpha.concat(numeric); 
// tworzy tablicę ["a", "b", "c", 1, 2, 3]</pre>
        <pre><b>Przykład: Połączenie trzech tablic</b>

num1 = [1, 2, 3];
num2 = [4, 5, 6];
num3 = [7, 8, 9];
nums = num1.concat(num2,num3) 
// tworzy tablicę [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
        <pre><b>Przykład: Połączenie wartości z tablicą</b> 

alpha = ['a', 'b', 'c'];
alphaNumeric = alpha.concat(1, 2, 3);
// tworzy tablicę ["a", "b", "c", 1, 2, 3]</pre>
        <li>SPREAD & REST OPERATOR</li>
        <ul>
            <li>
                <p>Operator spread zapisujemy jako "...". Wyjmuje on wszystkie eleementy tablicy i wypisuje jako
                    elementy.
                    Możożemy dzieki nie mu rowniez tworzyc inne tablice połączone z kilku
                    <pre>let drinks = ['mleko', 'woda', 'sok'];
let meals = ['chleb', 'mięso', 'frytki'];
                
console.log(...drinks),
// konsola wyloguje taki tekst - mleko woda sok
                
console.log(...drinks, ...meals);
// konsola wyloguje taki tekst - mleko woda sok chleb mięso frytki
                
let newArr = [...drinks, ...meals];
// utworzono nową tablicę newArr
//["mleko", "woda", "sok", "chleb", "mięso", "frytki"]

</pre>
            </li>
            <li>Operator rest - </li>
        </ul>

        </p>
        <li>SLICE (niedestrukcyjna)</li>
        <p>Wydobywa fragment tablicy i zwraca go jako nową tablicę.
            <pre>arr.slice([begin[, end]])</pre>
            <p><b>begin </b> <br>
                Indeks (liczony od zera) od którego zaczyna się wydobywanie. <br>
                Jeżeli indeks jest ujemny, begin wskazuje przesunięcie w kolejności od końca. slice(-2) wydobywa kolejno
                drugi od końca i ostatni element tablicy. <br>
                <b>end</b> <br>
                Indeks (liczony od zera) przed którym kończy się wydobywanie. slice wydobywa elementy jednakże nie
                zawiera end. <br>
                slice(1,4) wydobywa elementy od drugiego do czwartego (o indeksach 1, 2 i 3). <br>
                Jeżeli parametr ten ma wartość ujemną to end określa odległość od końca tablicy. slice(2,-1) wydobywa
                kolejne elementy od trzeciego do przedostatniego. <br>
                Jeżeli end jest pominięty, slice wydobywa wszystkie elementy do końca tablicy.</p>
            example:
            <pre></pre>
        </p>

        <li>SPLICE (destrukcyjna)</li>
        <p>Zmienia zawartość tablicy, dodając nowe elementy podczas usuwania starych elementów. Z wyciętych elementów
            tworzymy nową tablicę.
            <pre>array.splice(element od którego wycinamy (włącznie), <br> ilość usuwanych elementów[dodawane elementy i/lub tablice)</pre>
            examples:
            <pre>
let myFish = ["anioł", "klaun", "mandarynka", "jesiotr"];
        
let removed = myFish.splice(2, 0, "bęben");
//po drugim elemencie usuwamy jeden element i dodajemy element (bęben)
//tablica wygląda tak ["anioł","klaun","bęben","mandarynka","jesiotr"]       

removed = myFish.splice(3, 1)
//po 3 elemencie usuwamy jeden element (mandarynka)
//tablica wygląda tak [["anioł", "klaun", "bęben, "jesiotr"]

removed = myFish.splice(2, 1, "trąba")
//po drugim elemencie usuwamy jeden element (bęben) <br>i w tym miejscu dodajemy elememnt "trąba" <br> czyli jakby podmieniamy bęben na trąba
//tablica wygląda tak [ "anioł", "klaun", "trąba", "jesiotr" ]

removed = myFish.splice(0, 2, "papuga", "zawilec", "niebieski")
//usuwamy elementy do drugiego 2 (anioł i klaun) i w tym <br> miejscu dodajemy trzy elementy (papuga, zawilec, niebieski)
//tablica wygląda tak <br> ["papuga","zawilec","niebieski","trąba","jesiotr"]

removed = myFish.splice(3)
//usuwa  elementy wszystkie elementy od trzeciego
//tablica wygląda tak[ "papuga", "zawilec", "niebieski" ]

removed = myFish.splice(1,0,['kaczka', 'barka'])
//po 1 elemencie nic nie usuwamy i dodajemy tablicę z elememntami <br> kaczka i barka

// finalnie mamy tablice z elementami <br> ["papuga", ['kaczka', 'barka'],"zawilec", "niebieski"]</pre>

            //tablica removed = wartość wyciętych elementów
        </p>
        <li>POZOSTAŁE METODY</li>
        <ol>
            <li>join
                <p>Łączy wszystkie elementy tablicy w jeden łańcuch znaków (string). Można dodać string, który będzie
                    odzielał wszystkie elemety tablicy tym ciągiem (jeżli zostawimy pusty to wszystkie będą połączone
                    <pre>const arr = ['zielony', 'czerwony', 'niebieski'];
console.log(arr.join(''))
//wyloguje string 'zielonyczerwonyniebieski'
console.log(arr.join('+'))
//wyloguje string 'zielony+czerwony+niebieski'
console.log(arr.join(''))
//wyloguje string 'zielony,czerwony,niebieski'
console.log(arr.join(','))
//wyloguje string 'zielony,czerwony,niebieski'
console.log(arr.join(' , '))
//wyloguje string 'zielony , czerwony , niebieski'
</pre>
                </p>
            </li>
            <li>split
                <p>Ze strionga tworzy tablicę. Działa odwrotnie do toString i join. Można dodać wartość i jeśli taka
                    znajdzie się w stringu wykorzysta ją, usunie i będzie dzieliła stringa na elementy

                    <pre>const text = 'zielony +czerwony  +niebieski';

console.log(text.split())
//wyloguje  jedno elementową tablicę <br>[ "zielony czerwony  niebieski" ]
                        
console.log(text.split('+'))
//wyloguje trzyelementową tablicę <br>[ "zielony ", "czerwony  ", "niebieski" ]</pre>
                </p>
            </li>
            <li>filter
                <p>tworzy nową tablicę z wszystkimi elementami, które przechodzą test określony w postaci funkcji.
                    Przyyciu jej musimy użyć funkcji (mieć callbacka)

                    <pre>const numbers = [1, 15, 35, 2, 125, 32323,44, 286, 555];
function number(x){
return x%2 === 0;
};
console.log(numbers.filter(number))
//wyloguje tablicę z liczbami podzielnymi przez 2 z zerową resztą
//  number - nazwa fukncji (callback)
    x - pod ten element będzie podłożony
        i sprawedzony warunkiem kazdy element tablicy
        (nie musi być x - nazwa nie ma znaczenia)
    x%2 === 0 - warunek
                    </pre>
                </p>
            </li>
            <li>forEach
                <p>Wykonuje dostarczoną funkcję jeden raz na każdy element tablicy.
                    <pre>arr.forEach(callback[, thisArg])</pre>
                    <b>callback </b> <br>
                    Funkcja wykonywana dla każdego elementu. <br>
                    <b>thisArg</b> <br>
                    Obiekt na który będzie wskazywał this, gdy wykonana zostanie funkcja zwrotna callback.
                    <pre>const numbers = [1, 15, 35, 2, 125, 32323,44, 286, 555];
const newNumbers = numbers.forEach( x => console.log(x * 2))
// wylogowane zostanie kazdy element tablicy * 2
// wykorzystlismy tutaj funkcje strzałkową</pre>

                </p>
            </li>
            <li>includes()
                <p> ustala czy dana tablica posiada szukany element, zwracając true lub false. Można używać operatów
                    logicznych.
                    <pre>const numbers = [1, 5, 8, 30];
 console.log(numbers.includes(2))
//wyloguje false
console.log(numbers.includes(3+2))
//wyloguje true
console.log(numbers.includes(1 || 3))
//wyloguje true
console.log(numbers.includes(1 && 3))
//wyloguje false
</pre>
                </p>
            </li>
            <li>indexOf
                <p>Zwraca pierwszy (najmniejszy) indeks elementu w tablicy równego podanej wartości lub -1, gdy nie
                    znaleziono takiego elementu. Mżna zadeklarować od którego indexu przeszukiwac. 
                    <pre>array.indexOf(searchElement[, fromIndex = 0]);</pre>
                <pre>const numbers = [1, 5, 8, 30, 42, 83, 8, 12, 399];
console.log(numbers.indexOf(8))
//wyloguje 2
console.log(numbers.indexOf(42))
//wyloguje 4
console.log(numbers.indexOf(52))
//wyloguje -1
console.log(numbers.indexOf(8, 5))
//wyloguje 6

                </pre></p>
            </li>
            <li>lastIndexOf
                <p> Zwraca ostatni indeks, pod którym podany element może być znaleziony w tablicy, lub -1 jeśli nie jest obecny. Tablica jest przeszukiwana od końca, zaczynając od indeksu fromIndex
                    <pre>const numbers = [1, 5, 8, 30, 42, 83, 8, 12, 399];
console.log(numbers.lastIndexOf(8, 4))
//wyloguje 2
console.log(numbers.lastIndexOf(8))
//wyloguje 6
                    </pre>
                </p>
            </li>
            <li>reverse (metoda destrukcyjna)
                <p>Odwraca kolejność elementów w tablicy: pierwszy staje się ostatnim, ostatni pierwszym.
                    <pre></pre>const numbers = [1, 5, 8, 30];
                    console.log(numbers.reverse())
                    //wyloguje tablicę [ 30, 8, 5, 1 ]
                </p>
            </li>
            <li>sort
                <p>Sortuje elementy tablicy.</p>
                <p>
                    <pre>arr.sort([compareFunction])</pre>
                    <b>compareFunction</b> <br>
                    jest nazwą funkcji porównującej elementy. Jeżeli parametr zostanie pominięty, tablica będzie
                    posortowana w porządku leksykograficznym (alfabetycznie).</p>
                <p>Jeżeli compareFunction zostanie podana, elementy tablicy zostaną posortowane odpowiednio do wartości
                    zwracanej przez funkcję porównującą. Jeżeli a oraz b są dwoma porównywanymi elementami tablicy to:
                    <ul>
                        <li>compareFunction(a, b) zwróci wartość mniejszą od 0 - indeks elementu a będzie mniejszy niż
                            indeks b
                            (logicznie a < b)</li> <li>compareFunction(a, b) zwróci 0 - pozostawia a oraz b w
                                niezmienionej kolejności
                                względem siebie, jednak w dalszym ciągu oba będą porównywane z innymi elementami
                                (logicznie
                                b=a). Uwaga: Standard ECMAscript nie gwarantuje niezmienionej kolejności (np. Mozilla
                                wszystkie
                                wersje do 2003 roku).</li>
                        <li>compareFunction(a, b) zwraca wartość większą od 0 - indeks elementu a
                            będzie większy niż indeks b (logicznie a> b)</li>
                    </ul>
                    <pre>const numbers = [1, 5, 8, 30];
const names = ['Kris', 'Adam', 'Monika']

console.log(names.sort())
//wyloguje tablicę [ "Adam", "Kris", "Monika" ]

console.log(numbers.sort())                        
//wyloguje tablicę[ 1, 30, 5, 8 ]

console.log(numbers.sort(a,b) => a - b)
//wyloguje tabilcę [ 1, 5, 8, 30 ]
// działanie funkcja (strzałkowej) bierze dwa parametry (a i b) <br> odejmuje je od siebie, bierzze wyniki i sortuje po kolei


                    </pre>
                </p>

            </li>
            <li>toString
                <p>zwraca łańcuch znaków reprezentujący daną tablicę wraz z jej elementami. Tak jak pusta metoda join
                    <pre>const arr = ['zielony', 'czerwony', 'niebieski'];
console.log(arr.toString(','))
//zielony,czerwony,niebieski</pre>
                </p>
            </li>
            <li>toLocaleString
                <p>zwraca łańcuch znaków reprezentujący wszystkie elementy w tablicy. Każdy element jest konwerterowany do  łańcucha znaku za pomocą lokalnych wywołań toLocaleString. Elementy łaczone są separatorem zdefiniowanym dla lokalnego języka (np. przecinek).
                    <pre>let date = new Date()
const arr = [3500, date];
console.log(date)
//wylopgujeDate Mon Apr 20 2020 23:54:57 GMT+0200 (czas środkowoeuropejski letni)

console.log(arr.toLocaleString())
//wyloguje jednostkę, czas systemu uzytkownika
3500,20.04.2020, 23:57:41

console.log(arr.toLocaleString('en'))
//wyloguje jednostke czas zdefiniowany w metodzie
3,500,4/20/2020, 11:57:29 PM
                    </pre>
                </p>
            </li>
        </ol>
    </ol>



</body>

</html>